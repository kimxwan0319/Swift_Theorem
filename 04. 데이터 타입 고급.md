# 데이터 타입 고급

### 1. 컬렉션형

* **배열**

  ​	**같은 타입**의 데이터를 일렬로 나열한 후 순서대로 저장하는 형태의 타입이다.

  ​	필요에따라 버퍼의 크기를 조절해 주므로 **요소의 삽입 및 삭제가 자유롭다**. ( **동적이다.** )

  ​	배열은 각요소에 **인덱스**를 통해 접근할 수 있다. 

  ​	**인덱스는 0부터 시작한다.**

  ```swift
  var/let 배열이름 : [자료형] = [데이터1, 데이터2, ..., 데이터n]
  ```

  ```swift
  let arr : [String] = ["치킨", "피자", "짜장면", "족발" ]
  
  print(arr[2])
  
  ------result------
  짜장면
  ```

  ​	배열이 비었는지 확인하고 싶으면 배열이름뒤에 **.isEmpty**를 붙인다.

  ```swift
  let arr : [Int] = []
  
  print(arr.isEmpty)
  
  ------result------
  true
  ```

  ​	배열의 길이를 알고싶으면 배열이름뒤에 **.count**를 붙인다.

  ```swift
  let arr : [Int] = [1,3,5,7]
  
  print(arr.count)
  
  ------result------
  4
  ```

  ​	위에서 말햇듯이 스위프트의 배열은 **동적으로 확장**할 수 있다. 다음은 배열에 값을 동적으로 추가하는 방법들이다.

  * **append(_:)**

    > 배열의 맨 뒤에 요소를 추가

    ```swift
    배열이름.append(추가할 데이터)
    ```

  * **insert(_:at:)**

    > 중간에 요소를 삽입

    ```swift
    배열이름.insert(추가할 데이터, at: 인덱스 넘버)
    ```

  ```swift
  var brand : [String] = ["NIKE", "GUCCI", "Louis Vuitton"]
  
  brand.append("Stone Island") // ["NIKE", "GUCCI", "Louis Vuitton", "Stone Island"]
  brand.insert("BAPE", at: 2) // ["NIKE", "GUCCI", "BAPE", "Louis Vuitton", "Stone Island"]
  ```


* **딕셔너리**

  ​	요소들이 순서 없이 **키와 값의 쌍**으로 구성되는 컬렉션 타입.

  ​	키의 개수는 몇개여도 무관하다.

  ​	하나의 딕셔너리 안의 키의 이름은 **중복될 수 없다**. 

  ```swift
  var/let 딕셔너리 이름 : [키의 자료형 : 값의 자료형] = [키의 이름 : 값]
  ```

  ```swift
  var appleCost : [String : Int] = ["iPhone 11":990000, "AirPods":199000, "MacBook Pro":1990000]
  
  print(appleCost["iPhone 11"]) 
  ```

  ​	위 예제를 실행해보면 ```Optional(990000)```이 출력될것이다. 하지만 우리가 원하는 값은 ```990000```이다 이럴땐 !를 붙여주면 된다.

  ```swift
  print(appleCost["iPhone 11"]!) // 990000
  ```

  ​	위에서 나온 Optional에 대해선 나중에 다뤄보도록 하자.

* **세트**

  ​	같은 타입의 데이터를 순서 없이 하나의 묶음으로 저장하는 형태의 컬렉션 타입.

  ​	세트내의 모든값은 **모두 유일한 값**이다.(값이 중복되지 않는다.)

  ​	**순서가 중요하지 않거나 각 요소가 유일한 값이어야 하는 경우**에 사용한다. 

  ```swift
  var/let 세트이름 : Set<자료형> = [데이터1, 데이터2, ..., 데이터n]
  ```

  ```swift
  var chicken : Set<String> = ["교촌","푸라닭","BBQ","교촌"]
  
  print(chicken.count) //  3 - 중복된 값은 허용되지 않아 교촌은 1개만 남는다.
  ```

  ​	세트에 요소를 추가할때는 **insert(_:)** 메서드를 사용한다.

  ```swift
  세트이름.insert(추가할 데이터)
  ```

  ​	요소를 삭제하고싶다면 **remove(_:)** 메서드를 사용한다.

  ```swift
  세트이름.remove(삭제할 데이터)
  ```

  ​	세트는 내부의 값들이 모두 유일함을 보장하므로, **집합관계**를 표시하고자 할 때 유용하게 쓰일수있으며, 두 세트의 **교집합, 합집합** 등을 연산하기에 매우 용이하다.

  ```swift
  let C : Set<STring> = ["for","while","do-while"]
  let Swift : Set<STring> = ["for-in","while","repeat-while"]
  
  //교집합
  let intersect: Set<String> = C.intersection(Swift) // ["while"]
  
  //여집합의 합
  let symmetricDiff: Set<STring> = C.symmetricDifference(Swift)//["for","for-in","do-while","repeat-while"]
  
  //합집합
  let union: Set<String> = C.union(Swift)
  
  //차집합
  let subtract: Set<String> = C.subtracting(Swift)
  ```

  