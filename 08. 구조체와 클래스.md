# 구조체와 클래스

개념적으로 구조체와 클래스는 하나의 큰 코드 블록이다.

이 안에 변수나 상수를 넣어 값을 저장할 수도, 함수를 넣어 기능을 정의할 수도 있다.

다른 종류의 객체에 의존하지 않고 자체적으로  값을 저장하거나 함수적인 기능을 구현할 수 있다.

구조체나 클래스내에서 정의된 변수와 상수, 함수는 특별한 성격을 가지게 되며, 부르는 명칭이 달라진다.

* 변수나 상수 : **프로퍼티(Properties)**
* 함수 : **메소드(Method)**

이런 프로퍼티와 메소드를 합해서 구조체나 클래스의 **멤버(Member)**라고 표현한다.



## 구조체 VS 클래스

구조체와 클래스는 여러가지 면에서 유사한 성격을 띈다.

다음은 이들의 공통점이다.

* **프로퍼티**                변수나 상수를 사용하여 값을 저장하는 프로퍼티를 정의할 수 있다.
* **메소드**                   함수를 사용하여 기능을 제공하는 메소드를 정의할 수 있다.
* **서브스크립트**          속성값에 접근할 수 있는 방법을 제공하는 서브스크립트를 정의할 수 있다.
* **초기화 블록**            객체를 원하는 초기 상태로 설정해주는 초기화 블록을 정의할 수 있다. 
* **확장**                      객체에 함수적 기능을 추가하는 확장(extends) 구문을 사용할 수 있다.
* **프로토콜**                특정 형식의 함수적 표준을 제공하기 위한 프로토콜을 구현할 수 있다.



클래스의 기능범위는 구조체보다 크다.

다음은 구조체는 할 수 없지만, 클래스는 할 수 있는 기능들이다.

* **상속**                      클래스의 특성을 다른 클래스에게 물려줄 수 있다.
* **타입 캐스팅**           실행 시 컴파일러가 클래스 인스턴스의 타입을 미리 파악하고 검사할 수 있다.
* **소멸화 구문**           인스턴스가 소멸되기 직전에 처리해야 할 구문을 미리 등록해 놓을 수 있다.
* **참조의 의한 전달**    클래스 인스턴스가 전달될 때에는 참조 형식으로 제공되며, 이때 참조가 가능한 개수는 제약이 없다.



## 구조체와 클래스의 기본 개념

* **정의 구문**

  구조체와 클래스는 정의하는 구문 형식이 매우 비슷하다.

  구조체는 ``struct`` 키워드를, 클래스는 ``class`` 키워드를 사용하여 정의한다.

  * 구조체의 정의 형식

    ```swift
    struct 구조체_이름 {
      // 구조체 정의 내용
    }
    ```

  * 클래스의 정의 형식

    ```swift
    class 클래스_이름 {
      // 클래스 정의 내용
    }
    ```

  구조체와 클래스의 이름은 **파스칼 표기법**에 따른다.

* **메소드와 프로퍼티**

  구조체나 클래스 내부에서 정의된 변수나 상수를 **프로퍼티**, 함수는 **메소드** 라고 한다.

   일반 변수/상수/함수를 정의하는 것과 문법적으로 동일한다.

  ```swift
  struct AnyStruct {
    var x = 0
    var y = 0
    
    func anyFunc() -> String {
      return "AnyStruct 구조체"
    }
  }
  
  class AnyClass {
    var z : Int?
    var anyStruct = AnyStruct() // 밑에서 설명할 인스턴스이다.
    
    func anyFunc() -> String {
      return "AnyClass 클래스"
    }
  }
  ```

  위처럼 구조체나 클래스에 프로퍼티와 메소드를 정의할 수 있다.

  ``var y : Int?`` 같은 옵셔널 프로퍼티에 초기값이 할당되지 않았을땐 **자동으로 nil값으로 초기화** 된다.

* **인스턴스**

  구조체나 클래스는  실행할 수 있는 객체를 만들어주는 일종의 **틀**이다.

  우리는 이 틀으로서의 구조체나 클래스를 정의하지만. 여기에 직접 값을 담을수는 없다.

  이 틀로 만든 객체를 **인스턴스**라고 한다.

  인스턴스에는 실질적인 값을 담을 수 있다.

  클래스나 구조체 이름뒤에 빈 괄호를 붙여 각각의 인스턴스를 생성할 수 있다.

  ```swift
  let someStruct = AnyStruct()
  let someClass = AnyClass()
  ```

* **프로퍼티 접근**

  프로퍼티에 접근하려면 반드시 인스턴스를 먼저 생성해야한다.

  **점( . ) 문법**을 이용하여 인스턴스의 프로퍼티에 접근할 수 있다.

  ```swift
  let x = someStruct.x
  
  let y = someClass.anyStruct.y //하위레벨 프로퍼티 접근
  
  someClass.z = 10 //값 할당
  ```

  하위레벨 프로퍼티에 접근한것처럼 단계적으로 점 구문을 연결하는것을 **체인**이라고 한다.

* **구조체의 멤버 초기화**

  구조체는 모든 프로퍼티의 값을 인자값으로 입력받아 초기화하는 기본 초기화 구문을 제공한다.
  
  이를 **멤버와이즈 초기화 구문**이라고도 부른다.
  
  ```swift
  let someStruct = AnyStruct(x = 30, y = 40)
  ```
  
* **구조체의 값 전달 방식 : 복사에 의한 전달**

  값을 전달하는 방식은 구조체와 클래스의 결정적 차이 중의 하나이다.

  구조체는 인스턴스를 생성한 후 이를 변수/상수에 할당하거나 인자값으로 전달할때 **값을 복사하여 전달**한다.

  이를 **값 타입** 또는 **복사의 의한 전달**이라고 한다.

  ```swift
  let S1 = AnyStruct(x = 30, y = 40)
  let S2 = S1
  ```

  위 코드에서 ``AnyStruct`` 구조체의 인스턴스 ``S1``을 선언했고, ``S1``을 ``S2``라는 변수에 할당했다.

  ``S1``을 ``S2``에 할당하는 순간 복사되기때문에 이 둘은 완전히 다른 인스턴스이다.

  ```swift
  S2.x = 50
  
  print("S2의 x : \(S2.x)")
  print("S1의 x : \(S1.x)")
  
  ------result------
  S2의 x : 50
  S1의 x : 30
  ```

  ``S2`` 인스턴스의 ``x`` 프로퍼티에 50을 할당하면 ``S2``의 x는 50으로 바꼈지만, ``S1``의 ``x``값은 원래값인 30을 가지고 있는 것을 볼 수 있다.

  이는 두 인스턴스가 완전히 다른 개체로 다른 주소 공간에 저장되어 사용된다는것을 보여준다.

* **클래스의 값 전달 방식 : 참조에 의한 전달**

  클래스는 메모리 주소 참조에 의한 전달 방식을 사용한다.

  이를 **참조 타입**이라고 한다.

  ```swift
  let C1 = AnyClass()
  C1.z = 50
  ```

  위 코드에선 ``C1`` 이라는 ``AnyClass`` 클래스 인스턴스를 생성하고 ``z`` 에 50을 할당했다.

  ```swift
  let C2 = C1
  C2.z = 30
  ```

  ``C2``라는 상수를 만들어 위에서 선언한 ``C1`` 클래스 인스턴스를 할당하고 ``C2`` 의 ``z``값을 30으로 변경한다.

  

  ```swift
  print(C1.z!) //Anyclass의 프로퍼티, z는 Optional Int 타입이므로 !를 붙여 강제 해제를 해주었다.
  
  ------result------
  30
  ```

   ``C1``의 ``z``값을 출력했는데도 처음에 ``C1.z = 50``에서 할당한 50이 아니라 ``C2.z = 30``에서 변경한 30이 출력되었다.

  그 이유는 ``C2`` 상수가 ``C1`` 인스턴스를 참조했기 때문이다.

  * **식별 연산자**

    클래스는 참조 타입이기 때문에 여러 상수/변수에서 같은 인스턴스를 참조할 수 있다.

    상수/변수가 같은 인스턴스를 참조하고 있는지 비교하기 위해 식별 연산자를 사용한다.

    * **===** : 동일 인스턴스인지 비교할 때
    * **!==** : 동일 인스턴스가 아닌지 비교할 때

    ```swift
    if( C1 === C2 ){
      print("동일 인스턴스.")
    } else {
      print("다른 인스턴스.")
    }
    
    ------result------
    동일 인스턴스.
    ```

* **클래스와 구조체의 선택**

  언제 클래스를 사용하고 언제 구조체를 사용하면 좋을까?

  일반적으로 다음의 조건중 1개이상을 만족하면 구조체를 사용하는것을 추천한다.

  * 서로 연관된 몇 개의 기본 데이터 타입들을 캡슐화하여 묶는것이 목적일 때
  * 캡슐화된 데이터에 상속이 필요하지 않을 때
  * 갭슐화된 데이터를 전달하거나 할당하는 과정에서 참조 방식보다는 값이 복사되는 것이 합리적일 때
  * 캡슐화된 원본 데이터를 보존해야 할 때



## 프로퍼티

프로퍼티는 값에대한 저장 여부를 기준으로 **저장 프로퍼티**와 **연산 프로퍼티**로 분류할 수 있다.

* **저장 프로퍼티**
  * 입력된 값을 저장하거나 저장된값을 제공하는 역할
  * 상수 및 변수를 사용해서 정의가능
  * 클래스와 구조체에서는 사용이 가능하지만, 열거형에는 사용할 수 없음
* **연산 프로퍼티**
  * 특정 연산을 통해 값을 만들어 제공하는 역할
  * 변수만 사용해서 정의 가능
  * 클레스, 구조체, 열거형 모두에서 사용 가능

위 저장 프로퍼티와 연산 프로퍼티는 인스턴스가 있어야만 사용할 수 있다.

이렇게 인스턴스에 소속되는 프로퍼티를 **인스턴스 프로퍼티**라고 한다.

